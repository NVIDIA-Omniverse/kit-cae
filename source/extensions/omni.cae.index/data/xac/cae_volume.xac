// SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
//  its affiliates is strictly prohibited.

NV_IDX_XAC_VERSION_1_0


using namespace nv::index::xac;

// When sampling NanoVDB in a surface shader, this needs to match the NanoVDB data
// using vdb_grid_type = float;
// using vdb_grid_type = nanovdb::Fp8;
// using vdb_grid_type = nanovdb::Fp16;
// using vdb_grid_type = nanovdb::FpN;

// When sampling NanoVDB in a surface shader, this controls the filtering
// auto const vdb_filter_mode = VDB_volume_filter_mode::NEAREST;
auto const vdb_filter_mode = VDB_volume_filter_mode::TRILINEAR;
// auto const vdb_filter_mode = VDB_volume_filter_mode::TRIQUADRATIC;
// auto const vdb_filter_mode = VDB_volume_filter_mode::TRICUBIC;

#define PROGRAM_MODE_FLOAT 0
#define PROGRAM_MODE_VEC3F 1

// Sample overload for NanoVDB volumes
NV_IDX_DEVICE_INLINE
float sample(const uint attrib_idx, const VDB_volume& volume, const Sample_info_vdb& sample_info, const int mode)
{
    const float3 sample_position = transform_point(volume.get_scene_to_object_transform(), sample_info.scene_position);
    if (mode == PROGRAM_MODE_FLOAT)
    {
        // generate a volume sampler: filter and compression mode needs to be specified explicitly
        const auto sampler = volume.template generate_sampler<float, vdb_filter_mode, float>(attrib_idx);
        return sampler.fetch_sample(sample_position);
    }
    else if (mode == PROGRAM_MODE_VEC3F)
    {
        const auto sampler = volume.template generate_sampler<float3, vdb_filter_mode, nanovdb::Vec3f>(attrib_idx);
        const float3 val = sampler.fetch_sample(sample_position);
        return sqrtf(val.x * val.x + val.y * val.y + val.z * val.z);
    }
    else
        return 0.0f; // unsupported mode
}

// Sample overload for Irregular volumes
NV_IDX_DEVICE_INLINE
float sample(uint attrib_idx, const Irregular_volume& volume, const Sample_info_irregular_volume& sample_info, const int mode)
{
    // sample the irregular volume at the current position
    if (mode == PROGRAM_MODE_FLOAT)
    {
        return volume.fetch_attribute<float>(attrib_idx, sample_info.sample_cell_info);
    }
    else if (mode == PROGRAM_MODE_VEC3F)
    {
        const float3 val = volume.fetch_attribute<float3>(attrib_idx, sample_info.sample_cell_info);
        return sqrtf(val.x * val.x + val.y * val.y + val.z * val.z);
    }
    else
        return 0.0f; // unsupported mode
}

class Volume_sample_program
{
    NV_IDX_VOLUME_SAMPLE_PROGRAM
    int mode = PROGRAM_MODE_VEC3F;
    float fraction = 0.0f;
public:
    NV_IDX_DEVICE_INLINE_MEMBER
    void initialize()
    {
        fraction = *state.bind_parameter_buffer<float>(0);
        mode = *state.bind_parameter_buffer<int>(1);
    }

    NV_IDX_DEVICE_INLINE_MEMBER
    int execute(
        const Sample_info_self& sample_info,
              Sample_output&    sample_output)
    {
        // get reference to the volume and its colormap
        const auto& volume = state.self;
        const Colormap& colormap = state.self.get_colormap();

        // sample the volume at the current position
        float s0 = sample(0u, volume, sample_info, mode);
        if (fraction > 0.0f)
        {
            // apply linear interpolation if enabled
            const float s1 = sample(1u, volume, sample_info, mode);
            s0 = s0 + fraction * (s1 - s0);
        }

        // apply the colormap
        const float4 sample_color = colormap.lookup(s0);

        // store the output color
        sample_output.set_color(sample_color);

        return NV_IDX_PROG_OK;
    }
};